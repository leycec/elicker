#!/usr/bin/env zsh
# ====================[ elicker                            ]====================
#
# --------------------( NAME                               )--------------------
# elicker - run eLyXer under sane defaults and sanitize output HTML files
#
# --------------------( SYNOPSIS                           )--------------------
# elicker [ELYXER_OPTION]... SOURCE_LYX_DIR SOURCE_LYX_FILE TARGET_HTML_FILE
#
# --------------------( USAGE                              )--------------------
# Change the "Converter" of "LyX -> HTML" of "Tools->Preferences" from:
#
#    elyxer --directory $$r $$i $$o
#
# ...to:
#
#    elicker $$r $$i $$o
#
# Due to eLyXer inadequacies, we also recommend passing the following options in
# the above call to "elicker":
#
# * "--title '${title_name}'", where ${title_name} is the desired title for such
#   document. Sadly, eLyXer defaults such title to "Converted document".
#
# --------------------( INSTALLATION                       )--------------------
# elicker requires the following dependencies:
#
# * LyX >= 2.0.0.
# * eLyXer >= 1.2.5.
# * zsh >= 5.0.0.
#
# --------------------( DESCRIPTION                        )--------------------
# Convert the passed source LyX file in the passed directory into the passed
# target HTML file via external Python converter eLyXer passed the passed
# options. After running eLyXer, elicker sanitizes the produced HTML file.
#
# --------------------( SEE ALSO                           )--------------------
# * epubcheck, an open-source JAVA CLI utility for validating both the contents
#   of both EPUB2 and EPUB3 ebooks (as well generating proper ebook manifests):
#   https://github.com/IDPF/epubcheck

#FIXME: MathJax 2.3 is *INSANELY* huge, and it's only going to get larger. We
#desparately need to shrink this even further. Examining "du MathJax", it's
#clear that SVG output and non-TeX fonts (i.e., so-called web fonts) are yet
#more space hogs. The offending subdirectories are:
#
#* "fonts/HTML-CSS" excluding "./TeX", 13MB. This includes STIX fonts, which
#  most LaTeX commentators claim to be vastly inferior to TeX fonts. I would
#  probably concur with such claim, largely due to the fact that the STIX fonts
#  were designed by a consortium of corporations and governments of varying
#  budgets and motivations. Needless to say, the result is a bit hodgepodge.
#  This StackExchange confirms this suspicion:
#  http://meta.math.stackexchange.com/questions/11456/use-tex-fonts-by-default-even-if-stix-fonts-are-installed
#  Yup! Unsurprisingly, the STIX fonts are fairly terrible.
#* "jax/output/SVG", also 13MB.
#
#Altogether, excising such subdirectories nets us 26MB, which is probably
#essential. After doing so, consider also adopting the following MathJax
#configuration, courtesy a great GoogleGroups thread on slimming MathJax:
#https://groups.google.com/forum/#!topic/mathjax-users/2SrqHRd9tmA
#
#    <script type="text/x-mathjax-config">
#      MathJax.Hub.Config({
#        extensions: ["tex2jax.js"],
#        menuSettings: {zoom: "Double-Click", zscale: "300%"},
#        jax: ["input/TeX","output/HTML-CSS"],
#        MathMenu: {showRenderer: false},
#        "HTML-CSS": {
#            availableFonts: ["TeX"],
#            preferredFont: "TeX",
#            imageFont: null
#        }
#      });
#    </script>
#
#I'm not sure we require *ALL* of it, but the salient subsection appears to span
#from "jax:" to the last curly brace. I've confirmed the "HTML-CSS" fragment, at
#least, to be the canonical means of acheiving that effect. Yay!
#
#To enable such configuration, I'm afraid we'll have to obliterate eLyXer's
#default MathJax configuration and replace with it our own. Small price to pay,
#however!

#FIXME: Inform the user after completion of all target files and directories the
#user will need to save to retain a complete, working HTML document. This should
#include images as well as CSS and Javascript.
#FIXME: The "README.md" should explicitly document all of the nifty things we do
#here. Too many to exhaustively list here, so grep below!

# ....................{ GLOBALS                            }....................
# Current elicker version.
typeset -g ELICKER_VERSION='0.0.1'

# Minimum zsh version required by elicker.
typeset -g ELICKER_ZSH_VERSION_REQUIRED='4.3.0'

# Minimum eLyXer version recommended by elicker.
typeset -g ELICKER_ELYXER_VERSION_RECOMMENDED='1.2.5'

# elicker help printed when the caller passes option "--help".
typeset -g ELICKER_HELP='Usage: elicker [OPTIONS]... SOURCE_DIRECTORY SOURCE_LYX_FILE TARGET_HTML_FILE

A sanitary wrapper for eLyXer optimizing output content for real-world end use
(e.g., EPUB2 ebook readers), intended to be run from within LyX by changing the
"Tools->Preferences->File Handling->Converters" dialog field "Converter:" to:

    elicker --title "My Book Title" $$r $$i $$o

Since neither elicker or eLyXer are capable of automatically copying the title
from input LyX documents to output XHTML files, specify such title as above.

elicker supports all options and arguments supported by eLyXer, as well as
the following elicker-specific options:

      --platform PLATFORM     output content intended for the specified type of
                              publication PLATFORM, either "ebook" (the default)
                              or "website": e.g.,
         --platform ebook     output content intended for publication as
                              offline ebooks of any format
         --platform website   output content intended for publication directly
                              onto websites

      --quality QUALITY       output content of the specified QUALITY, either
                              "high" (the default) or "low": e.g.,
         --quality high       output high-quality content, intended for
                              publication either directly onto websites or as
                              EPUB3-conformant ebooks (e.g., KF8)
         --quality low        output low-quality content, intended for
                              publication as EPUB2- or MOBI-conformant ebooks

eLyXer options and arguments are as follows:
'

# ....................{ ZSH                                }....................
# If the current zsh version is less than such version, terminate with failure.
autoload -U is-at-least
is-at-least "${ELICKER_ZSH_VERSION_REQUIRED}" || {
    print "elicker: installed zsh ${ZSH_VERSION} < required zsh ${ELICKER_ZSH_VERSION_REQUIRED}" 1>&2
    exit 1
}

# Enforce strictness.
set -e

# Enable sane shell defaults.
setopt extended_glob no_unset null_glob rc_quotes rematch_pcre

# Enable exception handling.
autoload throw catch

# Load core zsh modules.
zmodload zsh/pcre zsh/parameter

# Print the passed message to standard output.
function print_message() {
    print "elicker: ${*}"
}

# Print the passed message to standard error.
function print_warning() {
    print "elicker: ${*}" 1>&2
}

# Print the passed message to standard error and throw a fatal exception
# terminating the current script.
function die() {
    print_warning "${*}"
    throw elicker_exception
}

# Print the passed message preceded by elyxer help to standard error and throw a
# fatal exception terminating the current script.
function die_with_help() {
    print_warning "${*}"$'\n\n'"${ELICKER_HELP}"
    command elyxer --help 1>&2
    
    throw elicker_exception
}

# ....................{ ELYXER                             }....................
local elyxer_version

# If eLyXer is *NOT* in the current ${PATH}, fail.
(( ${+commands[elyxer]} )) || die\
    '"elyxer" not installed or not in the current ${PATH}.'

# Parse the current eLyXer version from eLyXer standard error (!).
elyxer_version="$(elyxer --version 2>&1)"
if [[ "${elyxer_version}" == *(#b)(<->.<->.<->)* ]] {
    elyxer_version="${match[1]}"
} else {
    die "eLyXer version output \"${elyxer_version}\" contains no parseable version.
Consider installing at least eLyXer ${ELICKER_ELYXER_VERSION_RECOMMENDED}."
}

# If the current eLyXer version is less than recommended, print a warning.
is-at-least "${ELICKER_ELYXER_VERSION_RECOMMENDED}" "${elyxer_version}" ||
    print_warning "elicker: installed elyxer ${elyxer_version} < recommended zsh ${ELICKER_ELYXER_VERSION_RECOMMENDED}"

# ....................{ HELP                               }....................
# Validate sanity.
(( # )) || die_with_help 'Expected at least one argument.'

# If the caller passed a help-related argument (e.g., "--help"), pass all such
# arguments to "elyxer" as is without requiring the caller to have passed
# filenames as well.
if (( ${@[(i)--(help|lyxformat|version)]} <= ${#} )) {
    # If the caller passed option "--version", also print an "elicker" version.
    if (( ${@[(ie)--version]} <= ${#} )) {
        print "* elicker version ${ELICKER_VERSION}"
    }

    # If the caller passed option "--help", also print "elicker" help.
    if (( ${@[(ie)--help]} <= ${#} )) {
        print "${ELICKER_HELP}"
    }

    # By default, "elyxer" prints help output to both standard output and error,
    # a probable bug preventing such output from being cleanly redirected with a
    # pager (e.g., "less"). Fix this by redirecting standard error to output.
    command elyxer "${@}" 2>&1

    # Terminate this script successfully.
    exit 0
}

# ....................{ CLI                                }....................
# If the caller passed fewer than the required number of arguments, print the
# elicker help to standard error and terminate with failure.
(( # >= 3 )) || die_with_help\
    'Expected optional elicker and/or eLyXer options, one absolute base dirname, one absolute or relative source LyX filename, and one absolute or relative target HTML filename.'

local\
    dirname_src="${@[-3]}"\
    filename_src_lyx="${@[-2]}"\
    filename_trg_html="${@[-1]}"\
    filename_trg_html_old\
    dirname_trg
#print 'pwd: '${PWD}'\n$$r: '${dirname_src}'\n$$i: '${filename_src_lyx}'\n$$o: '${filename_trg_html}
#print "Current arguments: ${*}"

# Pop such filenames from the argument list, leaving only eLyXer options.
argv[-3,-1]=()

# Strip a suffixing "/" from such source directory, if present.
dirname_src="${dirname_src%/}"

# If such target file is an absolute path, set the target directory to the
# directory containing such file.
if [[ "${filename_trg_html}" == '/'* ]] {
    dirname_trg="${filename_trg_html:h}"
# Else, set the target directory to the current directory and prefix the target
# file by such directory.
} else {
    dirname_trg="${PWD}"
    filename_trg_html="${dirname_trg}/${filename_trg_html}"
}

# If such target directory is *NOT* writable, fail.
[[ -w "${dirname_trg}" ]] || die\
    '"'${dirname_trg}'/" unwritable by current user '${USER}'.'

# If such source file is *NOT* an absolute path, prefix such path by such target
# directory. Since the original source file may have been altered by a prior
# converter in the current conversion, obtain such file from where LyX copied it
# to in the target directory.
if [[ "${filename_src_lyx}" != '/'* ]] {
    filename_src_lyx="${dirname_trg}/${filename_src_lyx}"
}

# Insist eLyXer output to an intermediate target file rather than the passed
# target file that LyX expects. While we could permit eLyXer to instead output
# to the latter, preserving eLyXer's preprocessed output can be helpful for
# archival and debugging purposes.
filename_trg_html_old="${filename_trg_html%.html}_old.html"

# ....................{ OPTIONS                            }....................
# Map of elicker-specific command-line options passed to this script. Each map
# key is the name of such an option (always prefixed by "-" or "--"); each map
# value is the first shell word following such option if such option accepts a
# value or the empty string otherwise.
typeset -A elicker_options

# Set such map by parsing such options according to the passed option
# specifications, preserving unparsed options for subsequent parsing by the
# caller. If parsing fails, print the elicker help to standard error and
# terminate with failure. Dismantled, this is:
#
# * "-D", removing *ONLY* parsed options from the current argument list.
# * "-E", *NOT* halting parsing at the first option *NOT* matching a passed
#   option specification, thus ignoring all unspecified options.
# * "-M", parsing "="-prefixed substrings in option specifications as the
#   map key to parse such option into (e.g., "-help=h" parses long option
#   "--help" into map key '-h' rather than '--help'). By default, "="-prefixed
#   substrings denote the target list or map name to parse such option into.
# * "-A", parsing passed options into the above map.
zparseopts -M -D -E -A elicker_options -- -platform: -quality: ||
    die_with_help 'Invalid command-line argument(s).'
#print_message "elicker_options: ${(kv@)elicker_options}"

# ....................{ OPTIONS ~ platform                  }....................
# Enumeration identifying the intended platform of output content.
local platform='ebook'

# If the caller passed the "--platform" option, localize such option.
if (( ${+elicker_options[--platform]} )) {
    platform="${elicker_options[--platform]}"
}

# Validate such option.
[[ "${platform}" == ('ebook'|'website') ]] || die\
    "Platform \"${platform}\" unrecognized."

# ....................{ OPTIONS ~ quality                  }....................
# Enumeration identifying the intended quality of output content.
local quality='high'

# If the caller passed the "--quality" option, localize such option.
if (( ${+elicker_options[--quality]} )) {
    quality="${elicker_options[--quality]}"
}

# Validate such option.
[[ "${quality}" == ('high'|'low') ]] || die\
    "Quality \"${quality}\" unrecognized."

# ....................{ OPTIONS ~ print                    }....................
# Inform the user of all elicker-specific options.
print_message "Parsed elicker options:
    --platform ${platform}
    --quality ${quality}"

# ....................{ ELYXER                             }....................
# Set sane defaults for eLyXer options.
argv+=(
    # Inform eLyXer of the source directory containing external resources
    # required by such LyX document (e.g., embedded images).
    --directory "${dirname_src}"

    # Prevent eLyXer from printing a "Produced with eLyXer"-style footer.
    --nofooter
)

# If the caller passed no "--imageformat" option, coerce all non-JPEG bitmap
# images to JPEG. This substantially reduces file size with little to no
# discernable loss in visual quality. Due to hardware constraints under first-
# generation ebook readers, such reductions typically improve the portability of
# ebooks converted from such output. Likewise, due to bandwidth constraints
# under typical website hosts, such reductions also reduce the overhead of
# publishing books directly to websites.
if (( ${@[(ie)--imageformat]} > ${#} )) {
    argv+=( --imageformat '.jpg' )
}

# If the caller passed no "--css" option, attempt to find a local CSS file for
# use in the output HTML file.
if (( ${@[(ie)--css]} > ${#} )) {
    # If the canonical CSS file for eLyXer does *NOT* exist in the source
    # directory but *SOME* CSS file does, arbitrarily prefer the first such
    # file. In such case, print a warning as the user may not be expecting this.
    local filename_src_css="${dirname_src}/lyx.css"
    if [[ ! -f "${filename_src_css}" ]] {
        typeset -a filenames_src_css
        filenames_src_css=( "${dirname_src}/"*.css )

        # If such a file exists, prefer the first such file.
        if (( ${#filenames_src_css} )) {
            filename_src_css="${filenames_src_css[1]}"
            print_warning\
                "Defaulting to local CSS file \""${filename_src_css}"\".
Consider renaming such file to \"lyx.css\" to avoid this warning in the future."
        }
    }

    # If some such file exists, instruct eLyXer to use such file in lieu of its
    # default remote CSS file.
    if [[ -f "${filename_src_css}" ]] {
        # Copy such file to the target directory.
        cp -v "${filename_src_css}" "${dirname_trg}"

        # Pass the basename of such file to eLyXer, instructing eLyXer to always
        # find such file in the same directory as the output HTML file.
        argv+=( --css "${filename_src_css:t}" )
    }
}

# If the caller passed no math display options, sanely default such options.
if (( ${@[(ie)--mathjax]} > ${#} &&\
      ${@[(ie)--googlecharts]} > ${#} )) {
    # If producing low-quality ebooks, display math as bitmap images through
    # Google Charts.
    if [[ "${quality}" == 'low' ]] {
        argv+=( --googlecharts )
    # Else, display math dynamically through MathJax.
    } elif {
        local basename_mathjax='MathJax'
        local\
            dirname_src_mathjax="${dirname_src}/${basename_mathjax}"\
            dirname_trg_mathjax="${dirname_trg}/${basename_mathjax}"

        # If a source MathJax subdirectory exists, enable local MathJax usage.
        if [[ -d "${dirname_src_mathjax}" ]] {
            # If a target MathJax subdirectory already exists, inform the caller
            # that such subdirectory will be used as is.
            if [[ -d "${dirname_trg_mathjax}" ]] {
                print_warning\
                    "Reusing target temporary MathJax directory \"${dirname_trg_mathjax}\"."
            # Else, recursively copy the source MathJax subdirectory to the
            # target directory and remove all optional files and subdirectories
            # from such copy. This is critical, as the uncompressed MathJax
            # distribution rapidly approaches 100MB in size.  For further
            # details, see the quasi-official guide to "reducing the size of a
            # mathjax installation":
            # https://github.com/mathjax/MathJax-docs/wiki/Guide%3A-reducing-size-of-a-mathjax-installation
            #
            # Note that this is a "blacklist" approach, explicitly copying all
            # possible paths and then removing unwanted paths from such copy.
            # The alternative is a "whitelist" approach, explicitly copying only
            # the required paths and hence requiring no subsequent removal.
            #
            # While the latter is clearly more efficient, the former is
            # considerably more future-proof. We can be reasonably sure that all
            # currently optional files and subdirectories are likely to remain
            # optional regardless of future changes to MathJax structure and
            # content. We cannot, however, be reasonably sure that such changes
            # will *NOT* introduce requisite files or subdirectories which our
            # static implementation here would neglect to copy over. Hence, we
            # adopt the "blacklist" approach.
            } else {
                cp -rv "${dirname_src_mathjax}" "${dirname_trg}"

                # Remove MathJax paths guaranteed to be optional under all
                # custom MathJax configurations, including:
                #
                # * Documentation (e.g., "docs/", "LICENSE", "README*").
                # * Unit tests (e.g., "test/").
                # * Ancillary files (e.g., ".gitignore", "bower.json").
                rm -rf "${dirname_trg}"/{docs,test,unpacked}
                rm -f "${dirname_trg}"/{LICENSE,README*,.gitignore,bower.json}

                # Remove all stock MathJax configurations except "MMLorHTML.js",
                # explicitly referenced by eLyXer output. zsh to the rescue!
                rm -rf "${dirname_trg}"/config/*~*/MMLorHTML.js

                # Remove all image fonts. This is safe *ONLY* under custom
                # MathJax configurations setting "imageFont: null". Fortunately,
                # eLyXer guarantees such setting when using MathJax locally --
                # which, of course, this conditional ensures we are.
                rm -rf "${dirname_trg}"/fonts/HTML-CSS/TeX/png

                # Remove all non-TeX input options (e.g., MathML).
                rm -rf "${dirname_trg}"/jax/input~*/TeX

                # If tailoring output for ebooks, remove the following fonts
                # unlikely to ever be supported by ebook readers:
                #
                # * Starting with "MathJax_Win", Windows-specific fonts.
                # * In subdirectories "eot/", Internet Explorer-specific fonts.
                # * In subdirectories "svg/", Scalable Vector Graphics "fonts."
                #   Ebook support for SVG has always been spotty at best, and
                #   are unlikely to benefit from glyph-specific SVGs intended to
                #   be rendered inline text. Note this does *NOT* remove SVG as
                #   an output option, as MathJax renders SVG output separately.
                #   The following article's "Slimming down mathjax" section
                #   corroborates such choice:
                #   http://boolesrings.org/krautzberger/2011/10/17/epub-mathjax-and-the-ipad-another-attempt
                #
                # The following fonts should generally *NOT* be removed:
                #
                # * In subdirectories "woff", W3C-standardized web fonts
                #   explicitly supported by the EPUB3 standard.
                if [[ "${platform}" == 'ebook' ]] {
                    rm -rf "${dirname_trg}"/fonts/HTML-CSS/**/{eot,svg}
                    rm -f "${dirname_trg}"/fonts/HTML-CSS/**/MathJax_Win*
                }
            }

            # Pass the basename of such directory to eLyXer, instructing eLyXer
            # to always find such directory in the same directory as the output
            # HTML file.
            argv+=( --mathjax "${basename_mathjax}" )
        # Else, enable remote MathJax usage.
        } else {
            argv+=( --mathjax remote )
        }
    }
}

# Run eLyXer, converting such source to target file.
print_message "Running eLyXer as:
    elyxer ${*} \"${filename_src_lyx}\" \"${filename_trg_html_old}\""
command elyxer "${@}"\
    "${filename_src_lyx}"\
    "${filename_trg_html_old}"

# ....................{ POST-PROCESS                       }....................
print_message "Post-processing \"${filename_trg_html}\"..."

# Copy such temporary target file to the target file LyX expects.
cp "${filename_trg_html_old}" "${filename_trg_html}"

# Load zsh module "zsh/mapfile", providing both read and write access to text
# file contents by map global ${mapfile}, only for the exact duration of such
# access. Since unsetting map entries permanently, silently deletes the
# corresponding files, such module is inherently unsafe and should only be
# loaded as long as required.
zmodload zsh/mapfile
{
    # If displaying math via MathJax, modify HTML output accordingly.
    # For safety, performing such changes requires matching multiple lines.
    # While "awk" or "sed" could be employed to do so, both behave awkwardly
    # across multiple lines. Instead, leverage the the multiline-matching PCRE
    # facilities of zsh module "zsh/pcre" to do so. It should be noted that
    # XMLStarlet is a preferable means of modifying XML. Due to laziness and a
    # distate for additional dependencies, however, we take the hard way.
    if (( ${@[(ie)--mathjax]} <= ${#} )) {
        local mathjax_config mathjax_style
        print_message "Configuring sane MathJax defaults..."

        # Inline MathJax configuration to be inserted into the output HTML file
        # immediately prior to loading MathJax.
        local mathjax_config='<script type="text/x-mathjax-config">'

        # By default, MathJax provides no support for optional LaTeX macros
        # /nicefrac (which LyX enables by default) and /xfrac. Add such support
        # by augmenting MathJax's internal TeX parser to recognize such macro,
        # as documented by:
        # https://github.com/mathjax/mathjax-docs/wiki/Beveled-fraction-like-sfrac,-nicefrac-bfrac
        mathjax_config+='
  MathJax.Hub.Register.StartupHook("TeX Jax Ready", function () {
    var MML = MathJax.ElementJax.mml, TEX = MathJax.InputJax.TeX;
    TEX.Definitions.macros.nicefrac = "bevelledFractionParser";
    TEX.Definitions.macros.xfrac = "bevelledFractionParser";
    TEX.Parse.Augment({
      bevelledFractionParser: function (name) {
        var num = this.ParseArg(name),
            den = this.ParseArg(name);
        this.Push(MML.mfrac(num, den).With({bevelled: true}));
      }
    });
  });'

        # Conclude such configuration.
        mathjax_config+='
</script>
'

        # Inline MathJax CSS styles to be inserted into the output HTML file
        # immediately after loading MathJax and hence overriding MathJax's
        # default CSS styles.
        local mathjax_style='
<style>'

        # By default, MathJax displays math with a foreground grey color. Since
        # this is uniformly terrible and almost certainly undesirable for
        # professional print production, change such color to black.
        mathjax_style+='
  .MathJax_Preview { color: black !important }'

        # Conclude such styles.
        mathjax_style+='
</style>'

        # Regex matching lines loading MathJax's JavaScript library from the output
        # HTML file to ${match[1]}, designed so as to match the XHTML output by
        # eLyXer resembling:
        #
        #    # Output when accessing MathJax locally.
        #
        #    <script type="text/javascript" src="MathJax/MathJax.js">
        #      //  Load MathJax and get it running
        #      MathJax.Hub.Config({ jax: ["input/TeX"],
        #      config: ["MMLorHTML.js"],
        #      extensions: ["TeX/AMSmath.js","TeX/AMSsymbols.js"],
        #      "HTML-CSS": { imageFont: null }
        #      });
        #    </script>
        #
        #    # Output when accessing MathJax remotely.
        #    <script type="text/javascript"
        #      src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        #    </script>
        #
        # Note that "." matches all characters excluding newlines, here.
        mathjax_pcre='(<script\s++type="text/javascript"\s++src=".+?MathJax.js[^"]*+">[^<]*+</script>)'

        # Match such substring in such file.
        [[ "${mapfile[${filename_trg_html}]}" =~ "${mathjax_pcre}" ]] || die\
            '"'${filename_trg_html}'" fails to match PCRE "'${mathjax_pcre}'".'

        # Rewrite such file, embedding such substring unmodified between such
        # changes.
        mapfile[${filename_trg_html}]="${mapfile[${filename_trg_html}][1,MBEGIN-1]}${mathjax_config}${match[1]}${mathjax_style}${mapfile[${filename_trg_html}][MEND+1,-1]}"
    }

    # Remove all forward references to index and glossary entries from the body
    # of such document. While LaTeX hides such references by default, eLyXer
    # displays such references as Unicode down arrows. Since readers rarely care
    # whether and where the index or glossary references the current sentence,
    # hiding such references tends to produce significantly more readable and
    # navigable text.  Moreover, since titles can contain such references *AND*
    # since such references can be concatenated together, displaying such
    # references as arrows tends to produce unaesthetic output.
    #
    # Specifically, globally replace all "<a>...</a>" tags resembling:
    #
    # * <a class="IndexReference" name="entry-Fruit-patterns-Watermelon-spiral-0" href="#index-Fruit-patterns-Watermelon-spiral">↓</a>
    # * <a class="NomenclatureEntry" name="noment-vitalism" href="#nom-vitalism">↓</a>
    print_message "Removing empty forward references..."

    # Original text of such file. For efficiency, iteration below modifies
    # such text "in-place."
    local text_old="${mapfile[${filename_trg_html}]}"

    # Replaced text of such file.
    local text_new

    # While there exist substrings matching such PCRE in such text, dynamically
    # replace such substrings with their replacement. Since each such
    # replacement guaranteeably replaces such match, the implementation below
    # need *NOT* store the byte offset of the current match to string global
    # ${ZPCRE_OP} (unlike most PCRE match iterations). Such implementation
    # strongly resembles that of for_string_text_matching_pcre:() but differs enough to
    # warrant separation here. See such function for further details.
    #
    # For efficiency, avoid performing brute-force matching ala
    # 'while is "${text_old__rltmpbt}" =~ "${pcre__rltmpbt}" si {...}'. Such
    # approach does suffice to implement the desired iteration but could
    # conceivably recompile such PCRE on each iteration (depending on zsh
    # internals) and in any case is unlikely to optimize such compilation by
    # internally calling pcre_study().
    pcre_compile -- '<a[^>]++>↓</a>'
    pcre_study

    # Unfortunately, pcre_match() fails to set global integers ${MBEGIN} and
    # ${MEND} to the character indices of the start and end of the matched
    # substring. Fortunately, it sets global string ${ZPCRE_OP} to the " "-
    # delimited *BYTE* indices of the start and end of such substring.
    # Unfortunately, multibyte strings (e.g., UTF8-encoded) are indexed with
    # character rather than byte indices under default zsh option "multibyte".
    # Fortunately, such option can be locally disabled to force zsh to index all
    # strings (multibyte or not) with byte rather than character indices.
    unsetopt multibyte

    while { pcre_match -b -- "${text_old}" } {
        # If such substring is empty, throw an exception. This avoids infinite
        # loops on perverse PCREs matching only zero-width assertions or the
        # empty string.
        (( ${#MATCH} )) || die 'PCRE erroneously matched the empty string.'

        # Append the replaced text by the portion of the original text preceding
        # such match.
        text_new+="${text_old[1,${ZPCRE_OP[(w)1]}]}"

        # Reduce the original text to the portion following such match.
        text_old="${text_old[${ZPCRE_OP[(w)2]},-1]}"

        setopt multibyte
        text_old="${text_old[2,-1]}"
        unsetopt multibyte
    }

    # Set such scalar to such replaced text followed by all remaining original
    # text. To avoid extraneous string copies, inline such implementation.
    mapfile[${filename_trg_html}]="${text_new}${text_old}"

    # Reenable default character indexing.
    setopt multibyte
# For safety, unload "zsh/mapfile" even in the event of exceptions.
} always {
    zmodload -ui zsh/mapfile
}

# --------------------( WASTELANDS                         )--------------------
                # * "svg", purportedly required under old iOS iterations. (This
                #   should probably be verified!)
#FUXME: We need a new option "--platform" accepting either "ebook" or "website"
#(defaulting to "ebook"). When publishing for ebooks, we'll want to adjust
#behavior as follows:
#
#* If using MathJax locally, eliminate all "eot" and "woff" fonts, which are
#  web-specific fonts unlikely to ever be supported by ebook readers.

#FUXME: Our MathJax fixes may prove insufficient for real-world EPUB3 use. The
#blog article "How to include MathJax in an epub3 file to work with iBooks (and
#possibly others)" suggests a somewhat more robust MathJax configuration, as
#described at:
#
#    http://boolesrings.org/krautzberger/2013/01/13/how-to-include-mathjax-in-an-epub3-file-to-work-with-ibooks-and-possibly-others/
#
#At such article, the author also notes that "I went all the way and restricted
#output to SVG — to minimize things and to make it work. HTML output should work
#on iOS5, but last I checked Apple changed something on iOS6 that I couldn’t
#track down for lack of devices." This is interesting, because eLyXer currently
#restricts output to HTML+CSS rather than CSS. Food for future thought!
#
#    <script type="text/x-mathjax-config">
#    MathJax.Hub.Config({
#    jax: ["input/TeX","input/MathML","output/SVG"],
#    extensions: ["tex2jax.js","mml2jax.js","MathEvents.js"],
#    TeX: {
#    extensions: ["noErrors.js","noUndefined.js","autoload-all.js"]
#    },
#    MathMenu: {
#    showRenderer: false
#    },
#    menuSettings: {
#    zoom: "Click"
#    },
#    messageStyle: "none"
#    });
#    </script>
#    <script type="text/javascript" src="../mathjax/MathJax.js"> </script>

#FUXME: We need a new option "--platform" accepting either "ebook" or "website"
#(defaulting to "ebook"). When publishing to websites, we'll want to adjust
#behavior as follows:
#
#* If using MathJax locally, prefer "woff" fonts to all others.

#FUXME: Patch "elyxer" if <= 1.2.5 with the correct Google Charts image *IF AND
#ONLY IF* such option is enabled. This will require copying "elyxer" to
#${dirname_trg} if such file has not already been copied and patching it there
#-- ideally, with a simple "sed -ie" command. The culprit is:
#
#     u'googlecharts':u'http://chart.googleapis.com/chart?cht=tx&chl=', 
#
#...which should instead read:
#
#     u'googlecharts':u'http://chart.apis.google.com/chart?cht=tx&chl=', 
#FUXME: After successfully patching such issue, file a bug on eLyXer's tracker.

#FUXME: Remove inessential files from copied MathJax subdirectories. See:
#https://github.com/mathjax/MathJax-docs/wiki/Guide%3A-reducing-size-of-a-mathjax-installation

            # Trim the copy of MathJax in such target directory by removing
            # inapplicable files and subdirectories. For further details, see
                #FUXME: O.K.; here's where we perform MathJax compression. There
                #are two approaches: (a) copying over *ONLY* the set of required
                #files (whitelist approach) or (b) copying over everything and
                #then selectively removing unwanted files (blacklist approach).
                #While the former is clearly more efficient, the latter is
                #considerably more future-proof. After all, we can be reasonably
                #certain that we'll never need a certain file or subdirectory --
                #but can we ever be sure of what exactly we will need? Right.
                #
                #So let's go with approach (b), above. This implies we retain
                #the current recursive copy and then perform recursive remove
                #operations resembling:
                #
                #    find "${dirname_trg}" -name ... -delete
                #
                #Fairly sure I implemented similar functionality in a recent
                #ebuild. Ah, yes... Powerline. Relevant lines are:
                #
                #    # Remove all non-Python files from the original tree.
                #    find  powerline/bindings -type f -not -name '*.py' -delete
                #
                #    # Remove all Python files from the copied tree, for safety.
                #    find "${POWERLINE_SRC_DIR}" -type f -name '*.py' -delete


# ....................{ OPTIONS ~ quality                  }....................
# Enumeration identifying the intended quality of output content.
# local quality='high'
# 
# # Index of such option if passed or the number of passed arguments otherwise.
# integer quality_index="${@[(ie)--quality]}"
# 
# # If the caller passed the "--quality" option, localize such option.
# if (( quality_index <= ${#} )) {
#     quality="${@[quality_index]}"
# 
#     # Strip such option from such arguments to prevent eLyXer from panicking.
#     argv[quality_index]=()
# }
# 
# # Validate such option.
# [[ "${quality}" == ('high'|'low') ]] || die\
#     "Quality \"${quality}\" unrecognized."

#FUXME: Also support \xfrac LaTeX macros. One line addition, which is nice.
#FUXME: Permit the user to pass only two arguments by making the ${dirname_src}
#argument optional (defaulting to the dirname of the passed input LYX file).
#FUXME: Is there any tangible difference between the "website" and
#"ebook-quality-high" end uses? If not, elicker use could probably be simplified
#by simply providing a single "--quality" option currently accepting only two
#possible strings "low" and "high" (e.g., "--quality high").

# ....................{ ELICKER ~ quality                  }....................
# Enumeration identifying the intended use of output files.
# local quality='ebook-quality-high'
# 
# # Index of such option if passed or the number of passed arguments otherwise.
# integer quality_index="${@[(ie)--quality]}"
# 
# # If the caller passed the "--quality" option, localize such option.
# if (( quality_index <= ${#} )) {
#     quality="${@[quality_index]}"
# 
#     # Strip such option from the passed arguments.
#     argv[quality_index]=()
# }
# 
# # Validate such option.
# [[ "${quality}" == ('ebook-'('quality-low'|'quality-high')|'website') ]] || die\
#     "End use \"${quality}\" unrecognized."
# 
# Validate such option's dependencies.
# case "${quality}" {
# 'ebook-quality-low')
#     # (( ${+commands[rsvg-convert]} )) || die\
#     #     '"rsvg-convert" not installed or not in the current ${PATH}.'
#     ;;
# }

#  --quality quality              optimize output HTML for the passed quality,
#                                 either "website", "ebook-quality-high", or
#                                 "ebook-quality-low" as follows (defaults to
#                                 "ebook-quality-high"):
#
#    --quality website              output high-quality XHTML intended for
#                                   publication directly to a website
#    --quality ebook-quality-high   output high-quality XHTML intended for
#                                   publication as an EPUB3 and/or KF8 ebook
#    --quality ebook-quality-low    output low-quality XHTML intended for
#                                   publication as an EPUB2 and/or MOBI ebook

    # Else if *ANY* CSS file exists in such directory, arbitrarily prefer the
    # first such file in such directory. Since the user may not necessarily be
    # expecting this, print a warning.

    # directory, prefer such file to eLyXer's default remote CSS file.

    # Specifically:
    #
    # * Change the math color from default grey (bad!) to black (good).

 # This is a string
# constrained to the following choices:
#
# * "ebook-quality-low", instructing this script to output quality-low files
#   intended for use with EPUB2 and/or MOBI ebook readers.
# * "ebook-quality-high", instructing this script to output quality-high files
#   intended for use with EPUB3 and/or KF8 ebook readers.
# * "website", instructing this script to output quality-high files intended for
#   publication onto a website.
# , replacing "My Book Title" with the title of
# your current LyX document
# If producing quality-low ebooks via option "--quality ebook-quality-low",
# elicker also requires the following dependencies:
#
# * rsvg-convert >= 2.30.0. While Inkscape also produces acceptable output,
#   rsvg-convert tends to be more efficient and standards conformant.

        # If producing quality-low ebooks, configure MathJax to output SVGs rather
        # than HTML.
        # if [[ "${quality}" == 'ebook-quality-low' ]] {
        #     mathjax_config+=''
        # }

    # Establish sane MathJax defaults, including:
    #
    # * Creating SVG files when producing quality-low ebooks.
    # * Changing the math color from default grey (bad!) to black (good).

# Optional files and subdirectories of such directory.
# local\
#     dirname_src_mathjax="${dirname_src}/MathJax"\
#     filename_src_css="${dirname_src}/lyx.css"
    #FUXME: If this is *STILL* too slow, resort to in-place "sed". *shrug*

#   argv=( "${argv[1,quality_index-1]}" "${argv[quality_index+1,-1]}" )
#   mapfile[${filename_trg_html}]="${mapfile[${filename_trg_html}]//\<a[^>]#\>↓\</a\>}"
    # across multiple lines. Instead, leverage the text file expansion
    # facilities of zsh module "zsh/mapfile" along with the multiline-matching
    # PCRE facilities of zsh module "zsh/pcre" to do so. Since "zsh/mapfile" is
    # a rather unsafe module to leave loaded, load such module only for the
    # duration of such change.

    # Regex matching the loading of MathJax's JavaScript library from the output
    # HTML file to ${match[1]} and the remainder of such file to ${match[2]}.
#   local pcre='(.*?src=".*?MathJax.js[^"]++">\n</script>)(.*)'

#command sed -ie\
    #'s~\(</script>\)~\1<style>.MathJax_Preview { color: black !important}</style>~'\
    #"${filename_trg_html}"
# Directory containing the original source LyX file.
#dirname_src="${filename_src_lyx_old:h}"

# List set of all passed arguments, excluding repeated arguments and including
# sane defaults.
#typeset -Ua options
#options=( "${@[1,-4]}" '--nofooter' )

# Pop such filenames from the argument list, leaving only eLyXer options.
#argv[-2,-1]=()
