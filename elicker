#!/usr/bin/env zsh
# ====================[ elicker                            ]====================
#
# --------------------( NAME                               )--------------------
# elicker - run eLyXer under sane defaults and sanitize output HTML files
#
# --------------------( SYNOPSIS                           )--------------------
# elicker [ELYXER_OPTION]... SOURCE_LYX_DIR SOURCE_LYX_FILE TARGET_HTML_FILE
#
# --------------------( USAGE                              )--------------------
# Change the "Converter" of "LyX -> HTML" of "Tools->Preferences" from:
#
#    elyxer --directory $$r $$i $$o
#
# ...to:
#
#    elicker $$r $$i $$o
#
# Due to eLyXer inadequacies, we also recommend passing the following options in
# the above call to "elicker":
#
# * "--title '${title_name}'", where ${title_name} is the desired title for such
#   document. Sadly, eLyXer defaults such title to "Converted document".
#
# --------------------( INSTALLATION                       )--------------------
# elicker requires the following mandatory dependencies:
#
# * LyX >= 2.0.0.
# * eLyXer >= 1.2.5.
# * zsh >= 5.0.0.
#
# elicker benefits from but does *NOT* require the following optional
# dependencies:
#
# * YUI Compressor >= 2.4.8, for minifying (i.e., compressing) CSS files.
#
# --------------------( DESCRIPTION                        )--------------------
# Convert the passed source LyX file in the passed directory into the passed
# target HTML file via external Python converter eLyXer passed the passed
# options. After running eLyXer, elicker sanitizes the produced HTML file.
#
# --------------------( SEE ALSO                           )--------------------
# * epubcheck, an open-source JAVA CLI utility for validating both the contents
#   of both EPUB2 and EPUB3 ebooks (as well generating proper ebook manifests):
#   https://github.com/IDPF/epubcheck

#FIXME: Excise everything in the "WASTELANDS" prior to the first release. "Aww,
#shucks."

#FIXME: The "README.md" should explicitly document all of the nifty things we do
#here. Too many to exhaustively list here, so grep below!

# ....................{ ZSH                                }....................
# Minimum zsh version required by elicker.
typeset -g ELICKER_ZSH_VERSION_REQUIRED='4.3.0'

# If the current zsh version is less than such version, terminate with failure.
autoload -U is-at-least
is-at-least "${ELICKER_ZSH_VERSION_REQUIRED}" || {
    print "elicker: zsh version ${ZSH_VERSION} less than required version ${ELICKER_ZSH_VERSION_REQUIRED}" 1>&2
    exit 1
}

# Enable strictness, implicitly reporting failure (i.e., nonzero exit status)
# from the current context (e.g., function, script) on any command in such
# context reporting failure.
setopt err_return

# Enable sane shell defaults.
setopt extended_glob no_unset null_glob rc_quotes rematch_pcre

# Enable exception handling. For safety, suppress alias expansion while defining
# such functions with option "-U".
autoload -U throw catch

# Enable terminal color.
autoload -U colors
colors

# Load core zsh modules.
zmodload zsh/pcre zsh/parameter

# Load core zsh module "zstat", wrapping system call stat() with zsh function
# zstat() (rather than stat()).
zmodload -F zsh/stat b:zstat

# ....................{ GLOBALS                            }....................
# Current elicker version.
typeset -g ELICKER_VERSION='0.1.2'

# Minimum eLyXer version recommended by elicker.
typeset -g ELICKER_ELYXER_VERSION_RECOMMENDED='1.2.5'

# elicker help printed when the caller passes option "--help".
typeset -g ELICKER_HELP=${fg_no_bold[blue]}'Usage'${bold_color}': '${fg_bold[cyan]}'elicker '${fg_bold[black]}'['${fg_no_bold[cyan]}'OPTIONS'${fg_bold[black]}']'${fg_no_bold[white]}'... '${fg_no_bold[cyan]}'SOURCE_DIRECTORY SOURCE_LYX_FILE TARGET_HTML_FILE

'${fg_no_bold[white]}'An eLyXer wrapper tailoring output for real-world use (e.g., EPUB2 ebooks).

'${fg_bold[black]}'['${fg_bold[cyan]}'CONFIGURATION'${fg_bold[black]}']

'${fg_bold[white]}'elicker'${fg_no_bold[white]}' is intended to be run from within LyX itself. Change the '${fg_bold[magenta]}'"'${fg_no_bold[magenta]}'Converter:'${fg_bold[magenta]}'"
'${fg_no_bold[white]}'field of the '${fg_bold[magenta]}'"'${fg_no_bold[magenta]}'Tools / Preferences / File Handling / Converters / LyX -> HTML'${fg_bold[magenta]}'"'${fg_no_bold[white]}'
dialog to the following line (changing '${fg_bold[green]}'"'${fg_no_bold[green]}'My Book Title'${fg_bold[green]}'"'${fg_no_bold[white]}' to the desired title):

    '${fg_bold[white]}'elicker --title "My Book Title" $$r $$i $$o

'${fg_no_bold[white]}'Press '${fg_bold[magenta]}'"'${fg_no_bold[magenta]}'Modify'${fg_bold[magenta]}'"'${fg_no_bold[white]}' after editing such field. Due to inadequacies in eLyXer, the
output title must be changed on a per-document basis.

'${fg_bold[black]}'['${fg_bold[cyan]}'USAGE'${fg_bold[black]}']

'${fg_no_bold[white]}'Run '${fg_bold[white]}'elicker'${fg_no_bold[white]}' from within LyX by selecting '${fg_bold[magenta]}'"'${fg_no_bold[magenta]}'View / View (Other Formats) / HTML'${fg_bold[magenta]}'"'${fg_no_bold[white]}'.

If this successfully outputs a valid HTML file, consider re-editing the above
field to include recommended options '${fg_bold[green]}'--clean'${fg_no_bold[white]}', '${fg_bold[green]}'--force'${fg_no_bold[white]}', and '${fg_bold[green]}'--splitpart '${fg_no_bold[green]}'1'${fg_no_bold[white]}': e.g.,

    '${fg_bold[white]}'elicker --clean --force --splitpart 1 --title "The Watermelon Wave" $$r $$i $$o

'${fg_bold[black]}'['${fg_bold[cyan]}'OPTIONS'${fg_bold[black]}']

'${fg_no_bold[white]}'elicker explicitly supports the following options:

      '${fg_bold[green]}'--clean                 '${fg_bold[white]}'remove temporary paths from the target directory
                             '${fg_bold[black]}'['${fg_no_bold[white]}'by default, elicker preserves such paths without
                              modification'${fg_bold[black]}']

      '${fg_bold[green]}'--force                 '${fg_bold[white]}'always overwrite target paths that already exist
                             '${fg_bold[black]}'['${fg_no_bold[white]}'by default, elicker preserves such paths without
                              modification'${fg_bold[black]}']

      '${fg_bold[green]}'--platform '${fg_no_bold[green]}'PLATFORM     '${fg_bold[white]}'target the specified publication '${fg_no_bold[green]}'PLATFORM'${fg_no_bold[white]}', either 
                              '${fg_no_bold[magenta]}'"ebook" '${fg_bold[black]}'('${fg_no_bold[white]}'the default'${fg_bold[black]}')'${fg_no_bold[white]}' or '${fg_no_bold[magenta]}'"website"'${fg_no_bold[white]}': e.g.,
         '${fg_bold[magenta]}'--platform '${fg_no_bold[magenta]}'ebook     '${fg_no_bold[white]}'for use in offline ebooks of any type
         '${fg_bold[magenta]}'--platform '${fg_no_bold[magenta]}'website   '${fg_no_bold[white]}'for use on online websites of any type

      '${fg_bold[green]}'--quality '${fg_no_bold[green]}'QUALITY       '${fg_bold[white]}'target the specified publication '${fg_no_bold[green]}'QUALITY'${fg_no_bold[white]}', either
                              '${fg_no_bold[magenta]}'"high" '${fg_bold[black]}'('${fg_no_bold[white]}'the default'${fg_bold[black]}') '${fg_no_bold[white]}'or '${fg_no_bold[magenta]}'"low"'${fg_no_bold[white]}': e.g.,
         '${fg_bold[magenta]}'--quality '${fg_no_bold[magenta]}'high       '${fg_no_bold[white]}'for use in high-quality websites or EPUB3 ebooks
         '${fg_bold[magenta]}'--quality '${fg_no_bold[magenta]}'low        '${fg_no_bold[white]}'for use in low-quality EPUB2 or MOBI ebooks

'${fg_bold[black]}'['${fg_bold[cyan]}'ELYXER'${fg_bold[black]}']

'${fg_no_bold[white]}'elicker passes all other options directly to eLyXer and hence also supports all
options supported by eLyXer:
'

# ....................{ HELPERS ~ output                   }....................
# Print the passed message to standard output.
function print_message() {
    print "${fg_no_bold[blue]}elicker${bold_color}: ${fg_bold[white]}${*}${reset_color}"
}

# Print the passed message to standard error.
function print_warning() {
    print "${fg_no_bold[blue]}elicker${bold_color}: ${fg_bold[yellow]}${*}${reset_color}" 1>&2
}

# Print the passed message to standard error and throw a fatal exception
# terminating the current script.
function die() {
    print "${fg_no_bold[blue]}elicker${bold_color}: ${fg_bold[red]}${*}${reset_color}" 1>&2
    throw elicker_exception
}

# Print the passed message preceded by elyxer help to standard error and throw a
# fatal exception terminating the current script.
function die_with_help() {
    die "${*}"$'\n\n'"${ELICKER_HELP}"$'\n'"$(command elyxer --help 2>&1)"
}

# ....................{ SAFETY                             }....................
# If the current caller is effectively the superuser, terminate this script.
# We should *NEVER* be run as root or anyone resembling root.
(( EUID != 0 )) || die\
    'Expected non-root user. (Please: do not run elicker as root.)'

# ....................{ SAFETY ~ elyxer                    }....................
local elyxer_version

# If eLyXer is *NOT* in the current ${PATH}, fail.
(( ${+commands[elyxer]} )) || die\
    '"elyxer" not installed or not in the current ${PATH}.'

# Parse the current eLyXer version from eLyXer standard error (!).
elyxer_version="$(elyxer --version 2>&1)"
if [[ "${elyxer_version}" == *(#b)(<->.<->.<->)* ]] {
    elyxer_version="${match[1]}"
} else {
    die "eLyXer version output \"${elyxer_version}\" contains no parseable version.
Consider installing at least eLyXer ${ELICKER_ELYXER_VERSION_RECOMMENDED}."
}

# If the current eLyXer version is less than recommended, print a warning.
is-at-least "${ELICKER_ELYXER_VERSION_RECOMMENDED}" "${elyxer_version}" ||
    print_warning "eLyXer version ${elyxer_version} less than recommended ${ELICKER_ELYXER_VERSION_RECOMMENDED}."

# ....................{ HELPERS ~ paths                    }....................
# Safely recursively remove the passed directory. If such directory fails any of
# the following conditions, terminate this script rather than attempt to remove
# such path:
#
# * Such directory does not exist.
# * Such directory is relative rather than absolute.
# * Such directory contains relative path components (i.e., "./", "../").
# * Such directory resides in a system directory (e.g., "/etc", "/usr").
# * Such directory is a user's home directory (e.g., "/home/leycec").
function remove_dir() {
    # Validate sanity.
    (( # == 1 )) || die 'Expected one dirname.'
    local dirname="${1}"
    [[ -d "${dirname}" ]] || die "\"${dirname}\" not found or not a directory."
    [[ "${dirname}" == '/'* ]] || die "\"${dirname}\" not an absolute path."
    [[ "${dirname}" != *('/.'|'/..')('/'*|) ]] || die\
        '"'${dirname}'" contains relative path components (i.e., "./", "../").'

    # To simplify subsequent validation, canonicalize such path now that we're
    # know such path exists, is a directory, and has no risky components.
    dirname="$(print -r -- "${dirname}"(:A))"

    # Validation continues.
    [[ "${dirname}" != '/'(|'bin'|'boot'|'dev'|'etc'|'opt'|'proc'|'root'|'sbin'|'sys'|'usr'|'lib'[^/]#)('/'*|) ]] || die\
        '"'${dirname}'" resides in or is a system directory (e.g., "/etc", "/usr").'
    [[ "${dirname}" != '/home'('/'[^/]##|)('/'|) ]] || die\
        '"'${dirname}'" is a user''s home directory.'
#   's:^((\.?\*+/+)+.*|(/+\.?\*+)+.*|[\.\*/]+|.*/\.\*+)$::g')'

    # Recursively remove such directory. To prevent glob-reserved characters in
    # such path from being interpreted as a glob, double-quote such path.
    print_message "Removing directory \"${dirname}\"."
    rm -rf -- "${dirname}"
}

# ....................{ HELP                               }....................
# Validate sanity.
(( # )) || die_with_help\
    'Expected at least one command-line option or argument.'

# If a help-related option (e.g., "--help") was passed, pass all such options to
# "elyxer" as is without requiring filenames to have been passed as well.
if (( ${@[(i)--(help|lyxformat|version)]} <= ${#} )) {
    # If option "--version" was passed, also print an "elicker" version.
    if (( ${@[(ie)--version]} <= ${#} )) {
        print "* elicker version ${ELICKER_VERSION}"
    }

    # If option "--help" was passed, also print "elicker" help.
    if (( ${@[(ie)--help]} <= ${#} )) {
        print "${ELICKER_HELP}"
    }

    # By default, "elyxer" prints help output to both standard output and error,
    # a probable bug preventing such output from being cleanly redirected with a
    # pager (e.g., "less"). Fix this by redirecting standard error to output.
    command elyxer "${@}" 2>&1

    # Terminate this script successfully.
    exit 0
}

# ....................{ ARGUMENTS                          }....................
# If fewer than the required number of arguments were passed, print the elicker
# help to standard error and terminate with failure.
(( # >= 3 )) || die_with_help\
    'Expected optional elicker and/or eLyXer options, one absolute base dirname, one absolute or relative source LyX filename, and one absolute or relative target HTML filename.'

# Else, inform the user of elicker starting up.
print_message 'Starting.'

local\
    dirname_src="${@[-3]}"\
    filename_src_lyx="${@[-2]}"\
    filename_trg_html_main="${@[-1]}"\
    dirname_src_mathjax\
    dirname_trg
#print 'pwd: '${PWD}'\n$$r: '${dirname_src}'\n$$i: '${filename_src_lyx}'\n$$o: '${filename_trg_html_main}
#print "Current arguments: ${*}"

# Pop such filenames from the argument list, leaving only eLyXer options.
argv[-3,-1]=()

# Strip a suffixing "/" from such source directory, if present.
dirname_src="${dirname_src%/}"

# If such target file is an absolute path, set the target directory to the
# directory containing such file.
if [[ "${filename_trg_html_main}" == '/'* ]] {
    dirname_trg="${filename_trg_html_main:h}"
# Else, set the target directory to the current directory and prefix the target
# file by such directory.
} else {
    dirname_trg="${PWD}"
    filename_trg_html_main="${dirname_trg}/${filename_trg_html_main}"
}

# If such source directory does not exist, terminate this script.
[[ -d "${dirname_src}" ]] || die\
    "Source directory \"${dirname_src}/\" not found or not a directory."

# If such target directory does not exist, silently attempt to create such
# directory and all parents of such directory.
[[ -d "${dirname_trg}" ]] || command mkdir -pv -- "${dirname_trg}"

# If such target directory is *NOT* writable, fail.
[[ -w "${dirname_trg}" ]] || die\
    "Target directory \"${dirname_trg}/\" unwritable by current user ${USER}."

# If such target directory literally contains zero files (not even the canonical
# hard links "." or ".."), this script and hence LyX was probably run from a
# directory that no longer exists. In such case, terminate this script.
#
# Note that in such case, prior conditions testing the existence and writability
# of such directory succeed and hence are insufficient to avoid this edge case.
(( $(zstat +nlink -- "${dirname_trg}") )) || die\
    "Target directory \"${dirname_trg}/\" no longer exists."

# If such source file is *NOT* an absolute path, prefix such path by such target
# directory. Since the original source file may have been altered by a prior
# converter in the current conversion, obtain such file from where LyX copied it
# to in the target directory.
if [[ "${filename_src_lyx}" != '/'* ]] {
    filename_src_lyx="${dirname_trg}/${filename_src_lyx}"
}
# print "PWD: ${PWD}\ndirname_src: ${dirname_src}\ndirname_trg: ${dirname_trg}\nfilename_src_lyx: ${filename_src_lyx}\nfilename_trg_html_main: ${filename_trg_html_main}"

# ....................{ OPTIONS                            }....................
# Map of elicker-specific command-line options passed to this script. Each map
# key is the name of such an option (always prefixed by "-" or "--"); each map
# value is the first shell word following such option if such option accepts a
# value or the empty string otherwise.
typeset -A elicker_options

# Set such map by parsing such options according to the passed option
# specifications, preserving unparsed options for subsequent parsing by the
# caller. If parsing fails, print the elicker help to standard error and
# terminate with failure. Dismantled, this is:
#
# * "-D", removing *ONLY* parsed options from the current argument list.
# * "-E", *NOT* halting parsing at the first option *NOT* matching a passed
#   option specification, thus ignoring all unspecified options.
# * "-M", parsing "="-prefixed substrings in option specifications as the
#   map key to parse such option into (e.g., "-help=h" parses long option
#   "--help" into map key '-h' rather than '--help'). By default, "="-prefixed
#   substrings denote the target list or map name to parse such option into.
# * "-A", parsing passed options into the above map.
zparseopts -M -D -E -A elicker_options --\
    -clean \
    -force \
    -platform: \
    -quality: \
    || die_with_help 'Invalid command-line argument(s).'
#print_message "elicker_options: ${(kv@)elicker_options}"

# ....................{ OPTIONS ~ platform                  }....................
# Enumeration identifying the intended platform of output content.
local platform='ebook'

# If option "--platform" was passed, localize such option.
if (( ${+elicker_options[--platform]} )) {
    platform="${elicker_options[--platform]}"
}

# Validate such option.
[[ "${platform}" == ('ebook'|'website') ]] || die\
    "Platform \"${platform}\" unrecognized."

# ....................{ OPTIONS ~ quality                  }....................
# Enumeration identifying the intended quality of output content.
local quality='high'

# If option "--quality" was passed, localize such option.
if (( ${+elicker_options[--quality]} )) {
    quality="${elicker_options[--quality]}"
}

# Validate such option.
[[ "${quality}" == ('high'|'low') ]] || die\
    "Quality \"${quality}\" unrecognized."

# ....................{ OPTIONS ~ print                    }....................
# Human-readable synopsis of current elicker options, for debugging purposes.
local elicker_options_output="Enabling elicker options:${fg_no_bold[white]}"
if (( ${+elicker_options[--force]} )) {
    elicker_options_output+='
    --force'
}
if (( ${+elicker_options[--clean]} )) {
    elicker_options_output+='
    --clean'
}
elicker_options_output+="
    --platform ${platform}
    --quality ${quality}"

# Print such options.
print_message "${elicker_options_output}"

# ....................{ ELYXER                             }....................
# Set sane defaults for eLyXer options.
argv+=(
    # Inform eLyXer of the source directory containing external resources
    # required by such LyX document (e.g., embedded images).
    --directory "${dirname_src}"

    # Prevent eLyXer from printing a "Produced with eLyXer"-style footer.
    --nofooter
)

# If no "--imageformat" option was passed, coerce all non-JPEG bitmap images to
# JPEG. This substantially reduces file size with little to no discernable loss
# in visual quality. Due to hardware constraints under first- generation ebook
# readers, such reductions typically improve the portability of ebooks converted
# from such output. Likewise, due to bandwidth constraints under typical website
# hosts, such reductions also reduce the overhead of publishing books directly
# to websites.
if (( ${@[(ie)--imageformat]} > ${#} )) {
    argv+=( --imageformat '.jpg' )
}

# ....................{ ELYXER ~ css                       }....................
# If no "--css" option was passed, attempt to find a local CSS file for use in
# the output HTML file.
if (( ${@[(ie)--css]} > ${#} )) {
    # If the canonical CSS file for eLyXer does *NOT* exist in the source
    # directory but some CSS file does, arbitrarily prefer the first such file.
    # In such case, print a warning as the user may not be expecting this.
    local filename_src_css="${dirname_src}/lyx.css"
    if [[ ! -f "${filename_src_css}" ]] {
        typeset -a filenames_src_css
        filenames_src_css=( "${dirname_src}/"*.css )

        if (( ${#filenames_src_css} )) {
            filename_src_css="${filenames_src_css[1]}"
            print_warning\
                "Defaulting to source CSS file \""${filename_src_css}"\".
Consider renaming such file to \"lyx.css\" to avoid this warning in the future."
        }
    }

    # If some such file exists, instruct eLyXer to access the basename of such
    # file (and hence in the same directory as that of the target HTML file) in
    # lieu of the default remote CSS usage.
    if [[ -f "${filename_src_css}" ]] {
        argv+=( --css "${filename_src_css:t}" )
    }
}

# If option "--css" was passed...
integer css_index="${@[(ie)--css]}"
if ((   css_index <= ${#} )) {
    # Source CSS file, either relative or absolute.
    local filename_src_css="${@[css_index + 1]}"

    # If such file is relative (i.e., is *NOT* prefixed by "/"), assume such
    # file to be relative to such source directory.
    [[ "${filename_src_css}" == '/'* ]] ||
        filename_src_css="${dirname_src}/${filename_src_css}"

    # If such file does *NOT* exist, fail.
    [[ -f "${filename_src_css}" ]] || die\
        "\"${filename_src_css}/\" not found or not a file."

    # Target CSS file, guaranteed to be absolute.
    local filename_trg_css="${dirname_trg}/${filename_src_css:t}"

    # If such target file already exists...
    if [[ -f "${filename_trg_css}" ]] {
        # ...and its removal is requested, do so safely.
        if (( ${+elicker_options[--force]} )) {
            print_message 'Removing target CSS.'
            rm -- "${filename_trg_css}"
        # Else, preserve such file and warn the user.
        } else {
            print_warning\
                "Preserving target CSS file \"${filename_trg_css}\"
without modification. (Pass \"--force\" to replace such file.)"
        }
    }

    # If such target file no longer exists...
    if [[ ! -f "${filename_trg_css}" ]] {
        # If YUI Compressor is installed, compress such (presumably
        # uncompressed) source file to such target file.
        if (( ${+commands[yuicompressor]} )) {
            print_message 'Minifying target CSS with "yuicompressor".'
            command yuicompressor -v -o "${filename_trg_css}" -- "${filename_src_css}"
        # Else, copy such source file to such target file unmodified and
        # recommend YUI Compressor be installed.
        } else {
            print_message 'Copying target CSS.'
            cp -v -- "${filename_src_css}" "${dirname_trg}"
            print_warning 'Consider installing YUI Compressor. If installed, elicker automatically
minifies (i.e., compresses) target CSS.'
        }
    }
}

# ....................{ ELYXER ~ math                      }....................
# void install_mathjax(void)
#
# Recursively copy the source MathJax subdirectory to the target directory and
# remove all nonessential files and subdirectories from such copy. This is
# crucial, as the uncompressed MathJax distribution rapidly approaches 100MB in
# size. For further details, see the quasi-official guide to "reducing the size
# of a mathjax installation":
#
# https://github.com/mathjax/MathJax-docs/wiki/Guide%3A-reducing-size-of-a-mathjax-installation
#
# Note that this is a "blacklist" approach, explicitly copying all possible
# paths and then removing unwanted paths from such copy.  The alternative is a
# "whitelist" approach, explicitly copying only the required paths and hence
# requiring no subsequent removal.
#
# While the latter is clearly more efficient, the former is considerably more
# future-proof. We can be reasonably sure that all currently optional files and
# subdirectories are likely to remain optional regardless of future changes to
# MathJax structure and content. We cannot, however, be reasonably sure that
# such changes will *NOT* introduce requisite files or subdirectories which our
# static implementation here would neglect to copy over. Hence, we adopt the
# "blacklist" approach.
#
# For readability, aggregate all such MathJax path handling to this function.
function install_mathjax() {
    # Validate sanity.
    (( # == 0 )) || die "install_mathjax() expected no arguments."
    (( ${+dirname_trg_mathjax} )) || die 'String ${dirname_trg_mathjax} unset.'

    # Copy MathJax.
    print_message "Copying target MathJax."
    cp -r -- "${dirname_src_mathjax}" "${dirname_trg_mathjax}"

    # Remove MathJax paths guaranteed to be optional under all
    # custom MathJax configurations, including:
    #
    # * Documentation (e.g., "docs/", "LICENSE", "README*").
    # * Unit tests (e.g., "test/").
    # * Ancillary files (e.g., ".gitignore", "bower.json").
    #
    # Such removals explicitly state the paths to be removed and hence are
    # fundamentally safe -- or, at least safer than removals expanding only
    # variables (e.g., 'rm -rf -- "${dirname_trg_mathjax}"').
    print_message "Minifying target MathJax."
    rm -rf -- "${dirname_trg_mathjax}"/{docs,test,unpacked}
    rm -f  -- "${dirname_trg_mathjax}"/{LICENSE,README*,.gitignore,bower.json}

    # Remove all stock MathJax configurations except "MMLorHTML.js",
    # explicitly referenced by eLyXer output. zsh to the rescue!
    rm -rf -- "${dirname_trg_mathjax}/config/"*~*/MMLorHTML.js

    # Remove all image fonts. This is safe *ONLY* under custom
    # MathJax configurations setting "imageFont: null". Fortunately,
    # eLyXer guarantees such setting when using MathJax locally --
    # which, of course, this conditional ensures we are.
    rm -rf -- "${dirname_trg_mathjax}/fonts/HTML-CSS/TeX/png"

    # Remove all non-TeX input options (e.g., MathML).
    rm -rf -- "${dirname_trg_mathjax}/jax/input/"*~*/TeX

    # If tailoring output for ebooks, remove the following fonts
    # unlikely to ever be supported by ebook readers:
    #
    # * Starting with "MathJax_Win", Windows-specific fonts.
    # * In subdirectories "eot/", Internet Explorer-specific fonts.
    # * In subdirectories "svg/", Scalable Vector Graphics "fonts."
    #   Ebook support for SVG has always been spotty at best, and
    #   are unlikely to benefit from glyph-specific SVGs intended to
    #   be rendered inline text. Note this does *NOT* remove SVG as
    #   an output option, as MathJax renders SVG output separately.
    #   The following article's "Slimming down mathjax" section
    #   corroborates such choice:
    #   http://boolesrings.org/krautzberger/2011/10/17/epub-mathjax-and-the-ipad-another-attempt
    # * In all subdirectories of "fonts/HTML-CSS" excluding
    #   "fonts/HTML-CSS/TeX", non-TeX math fonts including the
    #   recently developed STIX fonts. Since the LaTeX community
    #   commonly considers TeX math fonts aesthetically superior to
    #   non-TeX math fonts and in particular the STIX fonts *AND*
    #   since TeX math fonts provide all necessary glyphs in all
    #   necessary font formats *AND* since numerous older browsers
    #   (e.g., Safari, WebKit) suffer discernable bugs when using the
    #   STIX fonts, there exists no to little incentive to retain
    #   non-TeX math fonts. Note this requires MathJax to be configured
    #   to use only TeX math fonts, below. For further opinionated
    #   details, see:
    #   http://meta.math.stackexchange.com/questions/11456/use-tex-fonts-by-default-even-if-stix-fonts-are-installed
    #
    # The following fonts should generally *NOT* be removed:
    #
    # * In subdirectories "woff", W3C-standardized web fonts
    #   explicitly supported by the EPUB3 standard.
    if [[ "${platform}" == 'ebook' ]] {
        rm -rf -- "${dirname_trg_mathjax}/jax/output/HTML-CSS/fonts/"*~*/TeX
        rm -rf -- "${dirname_trg_mathjax}/fonts/HTML-CSS/"*~*/TeX
        rm -rf -- "${dirname_trg_mathjax}/fonts/HTML-CSS/"**/{eot,svg}
        rm -f  -- "${dirname_trg_mathjax}/fonts/HTML-CSS/"**/MathJax_Win*

        # Also remove the SVG output option. Such option consumes a
        # considerable amount of space, while contributing comparatively
        # little: the HTML-CSS output option should suffice for EPUB3-
        # and hence MathJax-capable ebook readers. Note this requires
        # MathJax to be configured to use only the HTML-CSS output
        # option, below.
        rm -rf -- "${dirname_trg_mathjax}/jax/output/SVG"
    }
}

# If the caller passed no math display options, sanely default such options.
if (( ${@[(ie)--mathjax]} > ${#} &&\
      ${@[(ie)--googlecharts]} > ${#} )) {
    # If outputting with low quality, display math with compressed bitmap images
    # via Google Charts.
    if [[ "${quality}" == 'low' ]] {
        argv+=( --googlecharts )
    # Else, display math with vector-based TeX fonts via MathJax.
    } elif {
        # If the canonical MathJax directory for eLyXer does *NOT* exist in the
        # source directory but some directory containing the canonical MathJax
        # file "MathJax.js" does, arbitrarily prefer the first such directory.
        # In such case, print a warning as the user may not be expecting this.
        dirname_src_mathjax="${dirname_src}/MathJax"
        if [[ ! -d "${dirname_src_mathjax}" ]] {
            typeset -a filenames_src_mathjax
            filenames_src_mathjax=( "${dirname_src}/"*/MathJax.js )

            if (( ${#filenames_src_mathjax} )) {
                dirname_src_mathjax="${filenames_src_mathjax[1]:h}"
                print_warning\
                    "Defaulting to source MathJax directory \""${dirname_src_mathjax}"\".
Consider renaming such directory to \"MathJax\" to avoid this warning in the future."
            }
        }

        # If some such directory exists, instruct eLyXer to access the basename
        # of such directory (and hence in the same directory as that of the
        # target HTML file) in lieu of the default remote MathJax usage.
        if [[ -d "${dirname_src_mathjax}" ]] {
            argv+=( --mathjax "${dirname_src_mathjax:t}" )
        # Else, enable remote MathJax usage.
        } else {
            argv+=( --mathjax remote )
        }
    }
}

# If option "--mathjax" is enabled...
integer mathjax_index="${@[(ie)--mathjax]}"
if ((   mathjax_index <= ${#} )) {
    # Source MathJax directory, either relative or absolute, or "remote".
    dirname_src_mathjax="${@[mathjax_index + 1]}"

    # If such directory is local, customize local MathJax usage.
    if [[ "${dirname_src_mathjax}" != 'remote' ]] {
        # If such directory is relative (i.e., is *NOT* prefixed by "/"), assume
        # such directory to be relative to such source directory.
        [[ "${dirname_src_mathjax}" == '/'* ]] ||
            dirname_src_mathjax="${dirname_src}/${dirname_src_mathjax}"

        # If such directory does *NOT* exist, fail.
        [[ -d "${dirname_src_mathjax}" ]] || die\
            "\"${dirname_src_mathjax}/\" not found or not a directory."

        # Target MathJax directory, guaranteed to be absolute.
        local dirname_trg_mathjax="${dirname_trg}/${dirname_src_mathjax:t}"

        # If such target directory already exists...
        if [[ -d "${dirname_trg_mathjax}" ]] {
            # ...and its removal is requested, do so safely.
            if (( ${+elicker_options[--force]} )) {
                remove_dir "${dirname_trg_mathjax}"
            # Else, preserve such directory and warn the user.
            } else {
                print_warning\
                    "Preserving target MathJax directory \"${dirname_trg_mathjax}\"
without modification. (Pass \"--force\" to replace such file.)"
            }
        }

        # If such target directory no longer exists, copy MathJax there.
        [[ -d "${dirname_trg_mathjax}" ]] || install_mathjax
    }
# Else, undefine ${dirname_src_mathjax} to ensure fatal errors if such variable
# is subsequently erroneously accessed when option "--mathjax" is *NOT* passed.
# (This is purely for safety.)
} else {
    unset dirname_src_mathjax
}

# ....................{ ELYXER ~ run                       }....................
# Run eLyXer, converting such source to target file.
print_message "Running eLyXer as:${fg_no_bold[white]}
    elyxer ${*} \"${filename_src_lyx}\" \"${filename_trg_html_main}\""
command elyxer "${@}" "${filename_src_lyx}" "${filename_trg_html_main}"

# ....................{ POST-PROCESS                       }....................
# void process_file_trg_html(string filename_trg_html)
#
# Post-process the passed output HTML file.
function process_file_trg_html() {
    # Validate sanity.
    (( # == 1 )) || die "process_file_trg_html() expected one filename."
    local filename_trg_html="${1}"
    print_message 'Post-processing "'${filename_trg_html}'".'

    # If displaying math via MathJax, process such file accordingly.
    #
    # For safety, performing such changes requires matching multiple lines.
    # While "awk" or "sed" could be employed to do so, both behave awkwardly
    # across multiple lines. Instead, leverage the the multiline-matching PCRE
    # facilities of zsh module "zsh/pcre" to do so. It should be noted that
    # XMLStarlet is a preferable means of modifying XML. Due to laziness and a
    # distate for additional dependencies, however, we take the hard way.
    if (( ${+dirname_src_mathjax} )) {
        local mathjax_preamble mathjax_config mathjax_style
        print_message 'Reconfiguring MathJax.'

        # Inline MathJax startup hooks to be inserted into the output HTML file
        # immediately prior to loading MathJax.
        mathjax_preamble='<script type="text/x-mathjax-config">'

        # By default, MathJax provides no support for optional LaTeX macros
        # /nicefrac (which LyX enables by default) and /xfrac. Add such support
        # by augmenting MathJax's internal TeX parser to recognize such macro,
        # as documented by:
        # https://github.com/mathjax/mathjax-docs/wiki/Beveled-fraction-like-sfrac,-nicefrac-bfrac
        mathjax_preamble+='
  MathJax.Hub.Register.StartupHook("TeX Jax Ready", function () {
    var MML = MathJax.ElementJax.mml, TEX = MathJax.InputJax.TeX;
    TEX.Definitions.macros.nicefrac = "bevelledFractionParser";
    TEX.Definitions.macros.xfrac = "bevelledFractionParser";
    TEX.Parse.Augment({
      bevelledFractionParser: function (name) {
        var num = this.ParseArg(name),
            den = this.ParseArg(name);
        this.Push(MML.mfrac(num, den).With({bevelled: true}));
      }
    });
  });'

        # Conclude such hooks.
        mathjax_preamble+='
</script>
'

        # If installing MathJax locally for offline ebook production, configure
        # MathJax to support our prior removal of MathJax files and directories.
        if [[ "${dirname_src_mathjax}" != 'remote' &&
              "${platform}" == 'ebook' ]] {
            mathjax_config='
  MathJax.Hub.Config({
    jax: ["input/TeX", "output/HTML-CSS"],
    config: ["MMLorHTML.js"],
    extensions: ["TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    "HTML-CSS": {
      availableFonts: ["TeX"],
      preferredFont: "TeX",
      imageFont: null
    }
  });'
#   extensions: ["tex2jax.js"],
#   menuSettings: {zoom: "Double-Click", zscale: "300%"},
#   MathMenu: {showRenderer: false},
        }

        # Inline MathJax CSS styles to be inserted into the output HTML file
        # immediately after loading MathJax and hence overriding MathJax's
        # default CSS styles.
        mathjax_style='
<style>'

        # By default, MathJax displays math with a foreground grey color. Since
        # this is uniformly terrible and almost certainly undesirable for
        # professional print production, change such color to black.
        mathjax_style+='
  .MathJax_Preview { color: black !important }'

        # Conclude such styles.
        mathjax_style+='
</style>'

        # Regex matching lines loading MathJax's JavaScript library from the output
        # HTML file to ${match[1]}, designed so as to match the XHTML output by
        # eLyXer resembling:
        #
        #    # Output when accessing MathJax locally.
        #
        #    <script type="text/javascript" src="MathJax/MathJax.js">
        #      //  Load MathJax and get it running
        #      MathJax.Hub.Config({ jax: ["input/TeX"],
        #      config: ["MMLorHTML.js"],
        #      extensions: ["TeX/AMSmath.js","TeX/AMSsymbols.js"],
        #      "HTML-CSS": { imageFont: null }
        #      });
        #    </script>
        #
        #    # Output when accessing MathJax remotely.
        #    <script type="text/javascript"
        #      src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        #    </script>
        #
        # Such regex captures the following groups:
        #
        # * ${match[1]}, the opening <script...> tag.
        # * ${match[2]}, the content of such tag, either a custom MathJax
        #   configuration if installing MathJax locally or the empty string
        #   otherwise.
        # * ${match[3]}, the closing </script> tag.
        #
        # Since "." matches all characters excluding newlines by default *AND*
        # since the matched substring contains newlines, implicitly match
        # newlines via negated character classes (e.g., "[^<]").
        mathjax_pcre='(<script\s++type="text/javascript"\s++src=".+?MathJax.js[^"]*+">)([^<]*+)(</script>)'

        # Match such substring in such file.
        [[ "${mapfile[${filename_trg_html}]}" =~ "${mathjax_pcre}" ]] || die\
            '"'${filename_trg_html}'" fails to match PCRE "'${mathjax_pcre}'".'

        # Rewrite such file, embedding such substring unmodified between such
        # changes.
        mapfile[${filename_trg_html}]="${mapfile[${filename_trg_html}][1,MBEGIN-1]}${mathjax_preamble}${match[1]}${mathjax_config}${match[3]}${mathjax_style}${mapfile[${filename_trg_html}][MEND+1,-1]}"
    }

    # Remove all forward references to index and glossary entries from the body
    # of such document. While LaTeX hides such references by default, eLyXer
    # displays such references as Unicode down arrows. Since readers rarely care
    # whether and where the index or glossary references the current sentence,
    # hiding such references tends to produce significantly more readable and
    # navigable text.  Moreover, since titles can contain such references *AND*
    # since such references can be concatenated together, displaying such
    # references as arrows tends to produce unaesthetic output.
    #
    # Specifically, globally replace all "<a>...</a>" tags resembling:
    #
    # * <a class="IndexReference" name="entry-Fruit-patterns-Watermelon-spiral-0" href="#index-Fruit-patterns-Watermelon-spiral">↓</a>
    # * <a class="NomenclatureEntry" name="noment-vitalism" href="#nom-vitalism">↓</a>
    print_message 'Removing empty forward references.'

    # Original text of such file. For efficiency, iteration below modifies
    # such text "in-place."
    local text_old="${mapfile[${filename_trg_html}]}"

    # Replaced text of such file.
    local text_new

    # While there exist substrings matching such PCRE in such text, dynamically
    # replace such substrings with their replacement. Since each such
    # replacement guaranteeably replaces such match, the implementation below
    # need *NOT* store the byte offset of the current match to string global
    # ${ZPCRE_OP} (unlike most PCRE match iterations). Such implementation
    # strongly resembles that of for_string_text_matching_pcre:() but differs enough to
    # warrant separation here. See such function for further details.
    #
    # For efficiency, avoid performing brute-force matching ala
    # 'while is "${text_old__rltmpbt}" =~ "${pcre__rltmpbt}" si {...}'. Such
    # approach does suffice to implement the desired iteration but could
    # conceivably recompile such PCRE on each iteration (depending on zsh
    # internals) and in any case is unlikely to optimize such compilation by
    # internally calling pcre_study().
    pcre_compile -- '<a[^>]++>↓</a>'
    pcre_study

    # Unfortunately, pcre_match() fails to set global integers ${MBEGIN} and
    # ${MEND} to the character indices of the start and end of the matched
    # substring. Fortunately, it sets global string ${ZPCRE_OP} to the " "-
    # delimited *BYTE* indices of the start and end of such substring.
    # Unfortunately, multibyte strings (e.g., UTF8-encoded) are indexed with
    # character rather than byte indices under default zsh option "multibyte".
    # Fortunately, such option can be locally disabled to force zsh to index all
    # strings (multibyte or not) with byte rather than character indices.
    unsetopt multibyte

    while { pcre_match -b -- "${text_old}" } {
        # If such substring is empty, throw an exception. This avoids infinite
        # loops on perverse PCREs matching only zero-width assertions or the
        # empty string.
        (( ${#MATCH} )) || die 'PCRE erroneously matched the empty string.'

        # Append the replaced text by the portion of the original text preceding
        # such match.
        text_new+="${text_old[1,${ZPCRE_OP[(w)1]}]}"

        # Reduce the original text to the portion following such match.
        text_old="${text_old[${ZPCRE_OP[(w)2]},-1]}"

        setopt multibyte
        text_old="${text_old[2,-1]}"
        unsetopt multibyte
    }

    # Set such scalar to such replaced text followed by all remaining original
    # text. To avoid extraneous string copies, inline such implementation.
    mapfile[${filename_trg_html}]="${text_new}${text_old}"

    # Reenable default character indexing.
    setopt multibyte
}

# Inform the current user of such process.
print_message "Post-processing \"${dirname_trg}\"."

# List of all output HTML files, always containing at least the main such file.
typeset -a filenames_trg_html
filenames_trg_html=( "${filename_trg_html_main}" )

# If option "--splitpart" was passed, add all additional HTML files eLyXer
# produced to such list. Fortunately, such files match a simple pattern of the
# basename of the passed main output HTML file suffixed by "-", one or more
# characters (the name of the split part), and ".html".
if (( ${@[(ie)--splitpart]} <= ${#} )) {
    # Add all such files. Dismantled, this is:
    #
    # * ":r", strip the filetype from such filename.
    # * "?*", matching at least one character.
    filenames_trg_html+=( "${filename_trg_html_main:r}-"?*'.html' )

    # If no such files exist, print a warning. While this doesn't necessarily
    # indicate a fatal error (e.g., in the event no parts exist), it does
    # suggest the likelihood of one.
    if (( ${#filenames_trg_html} == 1 )) {
        print_warning\
            'Option "--splitpart" passed, but no files matching "'${filename_trg_html_main}'" found.'
    }
#FIXME: Actually, only do such if the size of the input LyX file exceeds a
#certain threshold (e.g., 100Kb).
# Else, recommend the user pass such option.
} else {
    print_warning\
        'Outputting all HTML to "'${filename_trg_html_main}'".
Consider passing "--splitpart 1" to output one HTML file per input chapter.'
}

# Post-process all output HTML files.
#
# Load zsh module "zsh/mapfile", providing both read and write access to text
# file contents by map global ${mapfile}, only for the exact duration of such
# access. Since unsetting map entries permanently, silently deletes the
# corresponding files, such module is inherently unsafe and should only be
# loaded as long as required.
zmodload zsh/mapfile
{
    local filename_trg_html
    for   filename_trg_html ("${filenames_trg_html[@]}") {
        process_file_trg_html "${filename_trg_html}"
    }
# For safety, unload "zsh/mapfile" even in the event of exceptions.
} always {
    zmodload -ui zsh/mapfile
}

# ....................{ POST-PROCESS ~ clean               }....................
# If requested, remove all temporary in such target directory.
if (( ${+elicker_options[--clean]} )) {
    print_message "Cleaning temporary paths."

    # Remove the eLyXer-specific temporary LyX file.
    rm -f -- "${filename_trg_html_main/.html(#e)/.lyx}"

    # Remove all LyX-specific temporary files. Dismantled, this is:
    #
    # * "<->", matching one or more integers.
    # * "(.)", matching only regular files.
    rm -f -- "${dirname_trg}/"<->lyxpreview*(.)
}

# ....................{ END                                }....................
print_message "Post-processed \"${dirname_trg}\"."

# --------------------( WASTELANDS                         )--------------------
    # (( ${+dirname_src_mathjax} + ${+dirname_trg_mathjax} == 2 )) || die\
    #     'Strings ${dirname_src_mathjax} and/or ${dirname_trg_mathjax} not set.'

    # Remove the elicker-specific temporary HTML file.
    # rm -f -- "${filename_trg_html_main_old}"

# Copy such temporary target file to the target file LyX expects.
#cp -v -- "${filename_trg_html_main_old}" "${filename_trg_html_main}"

# Insist eLyXer output to an intermediate target file rather than the passed
# target file that LyX expects. While we could permit eLyXer to instead output
# to the latter, preserving eLyXer's preprocessed output can be helpful for
# archival and debugging purposes.
#filename_trg_html_main_old="${filename_trg_html_main%.html}_old.html"

    # * ":t", reducing such filename to its basename.
#FUXME: Minify locally copied CSS files. (Not required for MathJax, of course.)
#FUXME: eLyXer appears to suffer a bug: figures with "%20" in filenames are
#silently broken. While we never noticed this before, it's certainly apparent
#now! We attempted disabling various possibly related elicker functionality, to
#no avail. I'm afraid while we'll simply have to rectify this in Ally's copy.
             # For efficiency, do so in a backgrounded subshell..
            # ( install_mathjax ) &

# If the current directory is ".", this script and hence LyX was probably run
# from a directory that no longer exists. If the case, terminate this script.
# if [[ "${PWD}" == '.' && ! -w "${PWD}" ]] {
#     die 'Current working directory no longer exists.'
# }
# [[ -w "${PWD}" ]] || print 'UGHUGH'

#FUXME: Subtle issue: if ${PWD} == '.', then we're probably in a directory that
#no longer exists. Check this and die if the case.

#FUXME: Before implementing option "--fork", research how to safely recursively
#remove directories in non-interactive shell scripts.
# ....................{ OPTIONS ~ production-dir           }....................
# Ancillary target directory containing no temporary LyX or LateX files.
# local dirname_trg_production

#FUXME: Implement me!
#--production-dir

# Neither elicker or eLyXer are capable of automatically setting the title
# of output content.
# from input LyX documents to output XHTML files, specify such title as above.

# elicker also supports all options and arguments supported by eLyXer, as well as
# the following elicker-specific options:
# eLyXer options and arguments are as follows:

#FUXME: To improve output readability, colorize output.

#   print_warning "${*}"$'\n\n'"${ELICKER_HELP}"
#   command elyxer --help 1>&2
#   throw elicker_exception

    # print ${fg_no_bold[blue]}'elicker'${bold_color}': '${fg_bold[white]}"${*}"
#FUXME: Silly and possibly unproductive. Just set the corresponding zsh-specific
#shell option below.

#FUXME: This must be generalized as below. If the user passed "--css", then such
#file must also be manually copied over as below. Don't bother with
#backgrounding such operations to a subshell. (This should be quite fast.)

        # If such target directory already exists, use such directory as is without
        # recopying for efficiency and inform the caller.
        # if [[ -d "${dirname_trg_mathjax}" ]] {
        #     print_warning\
        #         "Preserving target MathJax directory \"${dirname_trg_mathjax}\" without modification."
        # # Else, recursively copy the source MathJax subdirectory to the
        # # target directory and remove all nonessential files and subdirectories
        # # from such copy. For efficiency, perform such operations in a
        # # backgrounded subshell.
        # } else {

    # For efficiency, perform such removal in a backgrounded subshell.
    #FUXME: Arguably, other expensive file operations should *ALSO* be
    #backgrounded.

#FUXME: Add support for option "--clean". For efficiency, perform such cleaning
#in a backgrounded subshell. (Arguably, other expensive file operations should
#*ALSO* be backgrounded.)
#FUXME: Actually, a better solution would be to provide a new pair of options
#"--archive" and "--no-archive" (defaulting to "--archive") producing a
#compressed archive in the target directory containing all relevant files for
#production. Use a safe blacklist-oriented approach as follows:
#
#* Recursively copy all files and subdirectories in "${dirname_trg}" to a
#  temporary subdirectory of "${dirname_trg}", to guarantee writability -- say,
#  "${dirname_trg}/archive".
#* Remove all LyX-specific files from "${dirname_trg}/archive". Happily, these
#  are easily identifiable as all *FILES* (not directories) matching glob
#  <->lyxpreview*(.).
#
#For efficiency, perform such operations in a backgrounded subshell.
#
#If "${dirname_trg}/archive" already exists, simply print a nonfatal warning and
#do nothing. (Too dangerous, otherwise.)
#FUXME: Actually, a more useful option would probably be "--bundle-dir" (or some
#such) accepting a dirname defaulting to "${dirname_trg}/bundle". No need for
#compression and/or archival; creating a directory should suffice.
#FUXME: In keeping with eLyXer option nomenclature, how about
#"--destdirectoryslim"? *shrug* Bah! That's terrible. How about
#"--production-dir"? That's fairly explicit, yes?
#FUXME: Naturally, inform the user of such directory after completion.

            # Pass the basename of such directory to eLyXer, permitting the
            # output HTML file and such directory to be subsequently moved on
            # the filesystem without breaking such HTML.
        # Pass the basename of such file to eLyXer, instructing eLyXer to always
        # find such file in the same directory as the output HTML file.
        #FUXME: Not quite. Extend this as above; if "MathJax/" is not found,
        #fallback to finding the first subdirectory containing "MathJax.js".
#FUXME: Inform the user after completion of all target files and directories the
#user will need to save to retain a complete, working HTML document. This should
#include images as well as CSS and Javascript.

            # If such a file exists, prefer the directory containing the first
            # such file.
        # If such a file exists, prefer the first such file.
        # If a source MathJax subdirectory exists, enable local MathJax usage.
        # if [[ -d "${dirname_src}/MathJax" ]] {

      # --production-dir DIR    copy all output content to directory DIR
      #                        [consider specifying this option when running
      #                         elicker with LyX''s "View (Other Formats)->HTML"
      #                         menu item, to make production-quality directories
      #                         unpolluted by temporary LyX and LaTeX files]

#FUXME: MathJax 2.3 is *INSANELY* huge, and it's only going to get larger. We
#desparately need to shrink this even further. Examining "du MathJax", it's
#clear that SVG output and non-TeX fonts (i.e., so-called web fonts) are yet
#more space hogs. The offending subdirectories are:
#
#* "fonts/HTML-CSS" excluding "./TeX", 13MB. This includes STIX fonts, which
#  most LaTeX commentators claim to be vastly inferior to TeX fonts. I would
#  probably concur with such claim, largely due to the fact that the STIX fonts
#  were designed by a consortium of corporations and governments of varying
#  budgets and motivations. Needless to say, the result is a bit hodgepodge.
#  This StackExchange confirms this suspicion:
#  http://meta.math.stackexchange.com/questions/11456/use-tex-fonts-by-default-even-if-stix-fonts-are-installed
#  Yup! Unsurprisingly, the STIX fonts are fairly terrible.
#* "jax/output/SVG", also 13MB.
#
#Altogether, excising such subdirectories nets us 26MB, which is probably
#essential. After doing so, consider also adopting the following MathJax
#configuration, courtesy a great GoogleGroups thread on slimming MathJax:
#https://groups.google.com/forum/#!topic/mathjax-users/2SrqHRd9tmA
#
#    <script type="text/x-mathjax-config">
#      MathJax.Hub.Config({
#        extensions: ["tex2jax.js"],
#        menuSettings: {zoom: "Double-Click", zscale: "300%"},
#        jax: ["input/TeX","output/HTML-CSS"],
#        MathMenu: {showRenderer: false},
#        "HTML-CSS": {
#            availableFonts: ["TeX"],
#            preferredFont: "TeX",
#            imageFont: null
#        }
#      });
#    </script>
#
#I'm not sure we require *ALL* of it, but the salient subsection appears to span
#from "jax:" to the last curly brace. I've confirmed the "HTML-CSS" fragment, at
#least, to be the canonical means of acheiving that effect. Yay!
#
#To enable such configuration, I'm afraid we'll have to obliterate eLyXer's
#default MathJax configuration and replace with it our own. Small price to pay,
#however!

    # # Nonzero if local MathJax usage is enabled or zero otherwise.
    # integer is_mathjax_local=0

    #     # Inform subsequent logic of local MathJax usage.
    #     is_mathjax_local=1

# If option "--mathjax" is set to any value other than "remote", customize local
# MathJax usage.

            # Pass the basename of such directory to eLyXer, instructing eLyXer
            # to always find such directory in the same directory as the output
            # HTML file.
        #     argv+=( --mathjax "${basename_mathjax}" )
        # # Else, enable remote MathJax usage.
        # } else {
        #     argv+=( --mathjax remote )
        # }

                # * "svg", purportedly required under old iOS iterations. (This
                #   should probably be verified!)
#FUXME: We need a new option "--platform" accepting either "ebook" or "website"
#(defaulting to "ebook"). When publishing for ebooks, we'll want to adjust
#behavior as follows:
#
#* If using MathJax locally, eliminate all "eot" and "woff" fonts, which are
#  web-specific fonts unlikely to ever be supported by ebook readers.

#FUXME: Our MathJax fixes may prove insufficient for real-world EPUB3 use. The
#blog article "How to include MathJax in an epub3 file to work with iBooks (and
#possibly others)" suggests a somewhat more robust MathJax configuration, as
#described at:
#
#    http://boolesrings.org/krautzberger/2013/01/13/how-to-include-mathjax-in-an-epub3-file-to-work-with-ibooks-and-possibly-others/
#
#At such article, the author also notes that "I went all the way and restricted
#output to SVG — to minimize things and to make it work. HTML output should work
#on iOS5, but last I checked Apple changed something on iOS6 that I couldn’t
#track down for lack of devices." This is interesting, because eLyXer currently
#restricts output to HTML+CSS rather than CSS. Food for future thought!
#
#    <script type="text/x-mathjax-config">
#    MathJax.Hub.Config({
#    jax: ["input/TeX","input/MathML","output/SVG"],
#    extensions: ["tex2jax.js","mml2jax.js","MathEvents.js"],
#    TeX: {
#    extensions: ["noErrors.js","noUndefined.js","autoload-all.js"]
#    },
#    MathMenu: {
#    showRenderer: false
#    },
#    menuSettings: {
#    zoom: "Click"
#    },
#    messageStyle: "none"
#    });
#    </script>
#    <script type="text/javascript" src="../mathjax/MathJax.js"> </script>

#FUXME: We need a new option "--platform" accepting either "ebook" or "website"
#(defaulting to "ebook"). When publishing to websites, we'll want to adjust
#behavior as follows:
#
#* If using MathJax locally, prefer "woff" fonts to all others.

#FUXME: Patch "elyxer" if <= 1.2.5 with the correct Google Charts image *IF AND
#ONLY IF* such option is enabled. This will require copying "elyxer" to
#${dirname_trg} if such file has not already been copied and patching it there
#-- ideally, with a simple "sed -ie" command. The culprit is:
#
#     u'googlecharts':u'http://chart.googleapis.com/chart?cht=tx&chl=', 
#
#...which should instead read:
#
#     u'googlecharts':u'http://chart.apis.google.com/chart?cht=tx&chl=', 
#FUXME: After successfully patching such issue, file a bug on eLyXer's tracker.

#FUXME: Remove inessential files from copied MathJax subdirectories. See:
#https://github.com/mathjax/MathJax-docs/wiki/Guide%3A-reducing-size-of-a-mathjax-installation

            # Trim the copy of MathJax in such target directory by removing
            # inapplicable files and subdirectories. For further details, see
                #FUXME: O.K.; here's where we perform MathJax compression. There
                #are two approaches: (a) copying over *ONLY* the set of required
                #files (whitelist approach) or (b) copying over everything and
                #then selectively removing unwanted files (blacklist approach).
                #While the former is clearly more efficient, the latter is
                #considerably more future-proof. After all, we can be reasonably
                #certain that we'll never need a certain file or subdirectory --
                #but can we ever be sure of what exactly we will need? Right.
                #
                #So let's go with approach (b), above. This implies we retain
                #the current recursive copy and then perform recursive remove
                #operations resembling:
                #
                #    find "${dirname_trg}" -name ... -delete
                #
                #Fairly sure I implemented similar functionality in a recent
                #ebuild. Ah, yes... Powerline. Relevant lines are:
                #
                #    # Remove all non-Python files from the original tree.
                #    find  powerline/bindings -type f -not -name '*.py' -delete
                #
                #    # Remove all Python files from the copied tree, for safety.
                #    find "${POWERLINE_SRC_DIR}" -type f -name '*.py' -delete


# ....................{ OPTIONS ~ quality                  }....................
# Enumeration identifying the intended quality of output content.
# local quality='high'
# 
# # Index of such option if passed or the number of passed arguments otherwise.
# integer quality_index="${@[(ie)--quality]}"
# 
# # If the caller passed the "--quality" option, localize such option.
# if (( quality_index <= ${#} )) {
#     quality="${@[quality_index]}"
# 
#     # Strip such option from such arguments to prevent eLyXer from panicking.
#     argv[quality_index]=()
# }
# 
# # Validate such option.
# [[ "${quality}" == ('high'|'low') ]] || die\
#     "Quality \"${quality}\" unrecognized."

#FUXME: Also support \xfrac LaTeX macros. One line addition, which is nice.
#FUXME: Permit the user to pass only two arguments by making the ${dirname_src}
#argument optional (defaulting to the dirname of the passed input LYX file).
#FUXME: Is there any tangible difference between the "website" and
#"ebook-quality-high" end uses? If not, elicker use could probably be simplified
#by simply providing a single "--quality" option currently accepting only two
#possible strings "low" and "high" (e.g., "--quality high").

# ....................{ ELICKER ~ quality                  }....................
# Enumeration identifying the intended use of output files.
# local quality='ebook-quality-high'
# 
# # Index of such option if passed or the number of passed arguments otherwise.
# integer quality_index="${@[(ie)--quality]}"
# 
# # If the caller passed the "--quality" option, localize such option.
# if (( quality_index <= ${#} )) {
#     quality="${@[quality_index]}"
# 
#     # Strip such option from the passed arguments.
#     argv[quality_index]=()
# }
# 
# # Validate such option.
# [[ "${quality}" == ('ebook-'('quality-low'|'quality-high')|'website') ]] || die\
#     "End use \"${quality}\" unrecognized."
# 
# Validate such option's dependencies.
# case "${quality}" {
# 'ebook-quality-low')
#     # (( ${+commands[rsvg-convert]} )) || die\
#     #     '"rsvg-convert" not installed or not in the current ${PATH}.'
#     ;;
# }

#  --quality quality              optimize output HTML for the passed quality,
#                                 either "website", "ebook-quality-high", or
#                                 "ebook-quality-low" as follows (defaults to
#                                 "ebook-quality-high"):
#
#    --quality website              output high-quality XHTML intended for
#                                   publication directly to a website
#    --quality ebook-quality-high   output high-quality XHTML intended for
#                                   publication as an EPUB3 and/or KF8 ebook
#    --quality ebook-quality-low    output low-quality XHTML intended for
#                                   publication as an EPUB2 and/or MOBI ebook

    # Else if *ANY* CSS file exists in such directory, arbitrarily prefer the
    # first such file in such directory. Since the user may not necessarily be
    # expecting this, print a warning.

    # directory, prefer such file to eLyXer's default remote CSS file.

    # Specifically:
    #
    # * Change the math color from default grey (bad!) to black (good).

 # This is a string
# constrained to the following choices:
#
# * "ebook-quality-low", instructing this script to output quality-low files
#   intended for use with EPUB2 and/or MOBI ebook readers.
# * "ebook-quality-high", instructing this script to output quality-high files
#   intended for use with EPUB3 and/or KF8 ebook readers.
# * "website", instructing this script to output quality-high files intended for
#   publication onto a website.
# , replacing "My Book Title" with the title of
# your current LyX document
# If producing quality-low ebooks via option "--quality ebook-quality-low",
# elicker also requires the following dependencies:
#
# * rsvg-convert >= 2.30.0. While Inkscape also produces acceptable output,
#   rsvg-convert tends to be more efficient and standards conformant.

        # If producing quality-low ebooks, configure MathJax to output SVGs rather
        # than HTML.
        # if [[ "${quality}" == 'ebook-quality-low' ]] {
        #     mathjax_config+=''
        # }

    # Establish sane MathJax defaults, including:
    #
    # * Creating SVG files when producing quality-low ebooks.
    # * Changing the math color from default grey (bad!) to black (good).

# Optional files and subdirectories of such directory.
# local\
#     dirname_src_mathjax="${dirname_src}/MathJax"\
#     filename_src_css="${dirname_src}/lyx.css"
    #FUXME: If this is *STILL* too slow, resort to in-place "sed". *shrug*

#   argv=( "${argv[1,quality_index-1]}" "${argv[quality_index+1,-1]}" )
#   mapfile[${filename_trg_html_main}]="${mapfile[${filename_trg_html_main}]//\<a[^>]#\>↓\</a\>}"
    # across multiple lines. Instead, leverage the text file expansion
    # facilities of zsh module "zsh/mapfile" along with the multiline-matching
    # PCRE facilities of zsh module "zsh/pcre" to do so. Since "zsh/mapfile" is
    # a rather unsafe module to leave loaded, load such module only for the
    # duration of such change.

    # Regex matching the loading of MathJax's JavaScript library from the output
    # HTML file to ${match[1]} and the remainder of such file to ${match[2]}.
#   local pcre='(.*?src=".*?MathJax.js[^"]++">\n</script>)(.*)'

#command sed -ie\
    #'s~\(</script>\)~\1<style>.MathJax_Preview { color: black !important}</style>~'\
    #"${filename_trg_html_main}"
# Directory containing the original source LyX file.
#dirname_src="${filename_src_lyx_old:h}"

# List set of all passed arguments, excluding repeated arguments and including
# sane defaults.
#typeset -Ua options
#options=( "${@[1,-4]}" '--nofooter' )

# Pop such filenames from the argument list, leaving only eLyXer options.
#argv[-2,-1]=()
